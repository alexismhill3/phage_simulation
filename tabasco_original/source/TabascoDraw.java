import java.io.*;import java.util.StringTokenizer;import javax.swing.*;import java.awt.*;import java.awt.geom.*;import java.awt.image.*;/** Tabasco Draw is part of the visualization suite for the Tabasco stochastic simulator.   * Note: should consider making a single method to be implemented by the makeGraphic() and makeSingleGraphic() methods,*       since they are essentially identical.  Problem is my lack of understanding of combining Images.  Soemthing for later.**       Should also consider adding a check for the ScreenHeight, since the program blows up if it gets too big (Aside from it being																												 *       just non-user friendly with some super small scroll bar)  Instead could break it up into a few windows, something to*       consider adding somewhere, maybe in the TabascoReader.java file, it could break a large file up into pieces.* @author Jason Kelly* @author Sriram Kosuri* @version 1.0*/public class TabascoDraw{    	/**	 * An array, the size of the DNA molecule to be visualized, that contains information on the ID's of genetic elements on the DNA for display	 */	int[] dnaArray;	/**	 * An arry, the size of the DNA molecule to be visualized, that contains information on the protein complexes on the DNA.	 */    String[] complexArray;    /**	 * The number of timepoints to be visualized.	 */	int NUM_OF_TIMEPOINTS;    /**	 *  This is a reference to the ID system in Tobasco DPComplex which ID's the polymerases.	 */	int NUM_OF_STATIC_ID;    /**	 * The size of the DNA to be visualized in base pairs.	 */	int genomeSize;    /**	 * An array of colors for each molecule.	 */	Color[] molColorTable; //this is an array of colors for each molecule.        /**	 * The only constructor for this class.  	 * @param tRead The instance of TabascoRead that is reading the output of a simulation to be visualized	 */    public TabascoDraw(TabascoRead tRead){        NUM_OF_TIMEPOINTS = tRead.getTimePoints();// Read in the number of time points        genomeSize = tRead.getGenomeSize();        dnaArray = tRead.getDNAArray();        complexArray = new String[genomeSize];        NUM_OF_STATIC_ID = 10000; // this is a reference to the ID system in Tobasco DPComplex which ID's the polymerases.        // set the colors of the molecules    }        /**	 * This method takes in an image, and returns one with a molecule graph added.  This graph shows the levels of all the proteins and mRNA species on a log plot.  	 * @param molNames A vector containing the names of the molecules to be listed	 * @param molCopyNumber A vector that corresponds to the molNames containing the copy number of the particular molecule	 * @param molColors A vector containing a set of colors to iterate through when visualizing the protein levels	 * @param time The time to be displayed for this particular image	 * @param molGraphHeight The height of the molecule graph should take up in the original image	 * @return A new BufferedImage with a molecule graph replacing the lower portion of the image.	 */    public BufferedImage makeMoleculeGraph(String[] molNames, int[] molCopyNumber, Color[] molColors, double time,  int molGraphHeight, int Y_MARGIN, int[] rcopynumber,BufferedImage myImage){        // this could be a static method, since it just takes in an image file and returns a corrected one with        // the molecule graph added.  It does not depend on the specifics of an Instance of Tabascodraw since it is the        // same for all phages and brings in its own list of  molecules.                BufferedImage molGraphImage = myImage;        int numOfMolecules = molCopyNumber.length;        int heightOfBars = (int) (molGraphHeight/numOfMolecules);				int molXMARGIN = 10;        int yStart = Y_MARGIN+heightOfBars*2;        int xNameSize = 100;  //set the size of the width of the area to write the names        int xCopyNumSize = 110;        int yNameHeight = 8;        int tickSize = 150;        int xBarSizeMax = tickSize*6; // 10^6 molecules should be pretty safe i think.                int xBarStart = molXMARGIN+xNameSize+xCopyNumSize;        int xCopyNumStart =  molXMARGIN + xNameSize;        int xStatsStart =  molXMARGIN+xNameSize+xCopyNumSize+xBarSizeMax;//Starting location of the Stats                         Graphics2D g = molGraphImage.createGraphics();        Font f = new Font(null,Font.PLAIN,9);		g.setFont(f);		Rectangle2D rectangle = new Rectangle2D.Double();        		// Draw the tick marks.        for (int i=0;i<(numOfMolecules);i++){			            g.setPaint(Color.white);            //System.out.println(i + " : " + molNames[i]);			int EXTRA_PROT_SPACE = 10;            if(i>6){				g.drawString(molNames[i],molXMARGIN,yStart+(i*heightOfBars)+yNameHeight + EXTRA_PROT_SPACE);				int j=i-7;				if(i>=11)					j++;				g.drawString(rcopynumber[j] + "\t| " + molCopyNumber[i], xCopyNumStart, yStart+(i*heightOfBars)+yNameHeight + EXTRA_PROT_SPACE);				//draw protein level rectangle				g.setPaint(molColors[i]);				double barLength = (Math.log(molCopyNumber[i])/Math.log(10.0))*tickSize; //log is base e, need to convert to base 10.				if(barLength<0){					barLength=0;				}				rectangle.setFrame(xBarStart, yStart+(i*heightOfBars)+EXTRA_PROT_SPACE,barLength,heightOfBars);				g.fill(rectangle);				//draw mRNA line				g.setPaint(Color.white);				double mbarLength = (Math.log(rcopynumber[j])/Math.log(10.0))*tickSize; //log is base e, need to convert to base 10.				if(mbarLength<0){					mbarLength=0;				}				rectangle.setFrame((xBarStart+mbarLength-1), yStart+(i*heightOfBars)+EXTRA_PROT_SPACE,2,heightOfBars);				g.fill(rectangle);				rectangle.setFrame(xBarStart, yStart+(i*heightOfBars)+((int)heightOfBars/2)+EXTRA_PROT_SPACE,(mbarLength),1);				g.fill(rectangle);			}else if(i==5){				g.drawString(molNames[i],molXMARGIN,yStart+(i*heightOfBars)+yNameHeight);				//T7 RNA POLYMERASE 				int j=5;				g.drawString(rcopynumber[j] + "\t| " + molCopyNumber[i], xCopyNumStart, yStart+(i*heightOfBars)+yNameHeight);				//draw protein level rectangle				g.setPaint(molColors[i]);				double barLength = (Math.log(molCopyNumber[i])/Math.log(10.0))*tickSize; //log is base e, need to convert to base 10.				if(barLength<0){					barLength=0;				}				rectangle.setFrame(xBarStart, yStart+(i*heightOfBars),barLength,heightOfBars);				g.fill(rectangle);				//draw mRNA line				g.setPaint(Color.white);				double mbarLength = (Math.log(rcopynumber[j])/Math.log(10.0))*tickSize; //log is base e, need to convert to base 10.				if(mbarLength<0){					mbarLength=0;				}				rectangle.setFrame((xBarStart+mbarLength-1), yStart+(i*heightOfBars),2,heightOfBars);				g.fill(rectangle);				rectangle.setFrame(xBarStart, yStart+(i*heightOfBars)+((int)heightOfBars/2),(mbarLength),1);				g.fill(rectangle);			}			else{				g.drawString(molNames[i],molXMARGIN,yStart+(i*heightOfBars)+yNameHeight);				g.drawString("\t| " + molCopyNumber[i], xCopyNumStart, yStart+(i*heightOfBars)+yNameHeight);				g.setPaint(molColors[i]);				double barLength = (Math.log(molCopyNumber[i])/Math.log(10.0))*tickSize; //log is base e, need to convert to base 10.				if(barLength<0){					barLength=0;				}				rectangle.setFrame(xBarStart, yStart+(i*heightOfBars),barLength,heightOfBars);				g.fill(rectangle);			}            //System.out.println("number of mol" + i + ": " + barLength);                    }         //Draw the statistics.        g.setPaint(Color.white);//        double b = Math.round(a * 100d) / 100d;        g.drawString("| Time :  " + Math.floor(time), molXMARGIN, yStart+(-2*heightOfBars)+yNameHeight);        for(int i=0;i<6;i++){			int markerLength = (int) (Math.round(Math.log(Math.pow(10,i))/Math.log(10.0))) * tickSize;			g.drawString("|",markerLength+xBarStart,yStart+(-1*heightOfBars)+yNameHeight);			g.drawString("10^" + i,markerLength+xBarStart-8,yStart+(-2*heightOfBars)+yNameHeight);		}		return molGraphImage;    }        /**	 * This method takes in a Graphics2D object and draws an image depicting the nascentRNA levels of all the coding domains on the DNA.	 * @param theG The graphics2D object to edit from	 * @param rStart An array containing the startsites in base pairs of the coding domains on the DNA	 * @param rLength An array containing the lengths in base pairs of the coding domains on the DNA.  The indices correspond to those in rStart	 * @param rCopyNumber An array containing the copy numbers of the coding domains on the DNA.  THe indices correspond to those in rStart	 * @param startX The x position in the Graphics2D context where the drawing of the genome begins	 * @param startY The y position in the Graphics2D context where the drawing of the genome begins	 * @param colorArray The set of colors to use for the polymerasess and proteins displayed on the DNA	 * @param heightScale A scaling factor that is used to scale different sized simulations	 * @param bpPerPixel The number of base pairs that are representative of a single pixel.	 * @returns The updated Graphics2d containing the visualization of the nascentRNA.	 */    public static Graphics2D makeMRNAGraphic(Graphics2D theG, int[] rStart, int []rLength, int[] rCopyNumber, int startX, int startY, Color[] colorArray, int heightScale, int bpPerPixel){                int numOfMRNA = rCopyNumber.length;        int TEXT_HEIGHT = 10;        Rectangle2D rectangle = new Rectangle2D.Double();                for (int i=0; i<numOfMRNA; i++){            double rThick = (Math.log(rCopyNumber[i])/Math.log(10.0)) * heightScale;			if(i<5){			theG.setPaint(colorArray[i]);            }else if(i==5){				theG.setPaint(Color.red);				}else{				theG.setPaint(colorArray[i-1]);			}						//theG.drawString(""+ rCopyNumber[i],startX + (rStart[i]/bpPerPixel),startY-TEXT_HEIGHT);            if (rThick != Float.NEGATIVE_INFINITY){            //rectangle.setFrame(startX + (rStart[i]/bpPerPixel),startY, rLength[i]/bpPerPixel, rThick);				rectangle.setFrame((rStart[i]/bpPerPixel),startY, rLength[i]/bpPerPixel, rThick);				theG.fill(rectangle);            }        }                return theG;    }	/**     * This is the method that sets the characteristics of the DNA visualization, and runs the other methods in this class within it.	 * @param ca An array containing a string of numbers that defines the type and instance of complexes on the dna.	 * @param rstart An array containing the startsites in base pairs of the coding domains on the DNA	 * @param rlength An array containing the lengths in base pairs of the coding domains on the DNA.  The indices correspond to those in rStart	 * @param rcopynumber An array containing the copy numbers of the coding domains on the DNA.  THe indices correspond to those in rStart	 * @param entDNA The last position on the genome that has entered the cell	 * @param rowNum The current DNA molecules to display;  Sometimes mutiple pieces of DNA will be shown on different rows for the same simulation 	 * @param totRows The total number of DNA molecules to display.	 * @param myImage The image to draw the DNA on	 * @param dnaArray An array describing the elements on the DNA at each DNA position.	 */	    public static BufferedImage makeSingleGraphic(String[] ca, int[] rstart, int []rlength, int[] rcopynumber, int entDNA, int rowNum, int totRows, BufferedImage myImage, int[] dnaArray){        /* set characteristics of the DNA visualization.  At later time should make these "gettable and settable"         * and should have only one set of them for both visualization types.         */        int rowNumber = rowNum; // this defines which row to draw the single graphic into.        int totalRows = totRows;        BufferedImage testImage = myImage;        int enteredDNA = entDNA;        //complexArray = ca;        int scale = 1;                       // this is jsut a convenient way to adjust the size for the animation.                int POLYMERASE_HEIGHT = 6*scale;        int PROMOTER_HEIGHT = 6*scale;        int TERMINATOR_HEIGHT = 6*scale;        int NORMAL_DNA_HEIGHT = 1*scale;        int BP_PER_PIXEL = 40;        int X_EDGE_MARGIN = 10;             // X-axis Margins        int Y_EDGE_MARGIN = 10;             // Y-axis Margins        int MOL_GRAPH_HEIGHT = 558;         // height of the molecules graph.        int ROW_HEIGHT = (testImage.getHeight()-(Y_EDGE_MARGIN)-MOL_GRAPH_HEIGHT)/totalRows; //row height is determined based on the image hieght and the number of rows.        int RNA_ROW_HEIGHT = ((ROW_HEIGHT*4)/10);        int DNA_ROW_HEIGHT = ((ROW_HEIGHT*6)/10);                //System.out.println(ROW_HEIGHT + "... " + RNA_ROW_HEIGHT + "... " + DNA_ROW_HEIGHT);        int NUM_OF_TIMEPOINTS = 1;//complexArray.length;        //it is expected that        int genomeSize = ca.length;        int ENTERED_DNA_WIDTH = 1*scale;        int ENTERED_DNA_HEIGHT = 15*scale;        int[] rnaStart = rstart;        int[] rnaLength = rlength;        int[] rnaCopyNumber =rcopynumber;                Graphics2D g = testImage.createGraphics();                int NUM_BETWEEN_TRACERS=25; //this is the number of polymerases to show between "tracer" polymerases        int compX = X_EDGE_MARGIN;        int dnaRectWidth=0;        int compRectWidth=0;        //int y = MOL_GRAPH_HEIGHT +Y_EDGE_MARGIN+(ROW_HEIGHT*rowNum);        int y = Y_EDGE_MARGIN+(ROW_HEIGHT*rowNum);		        // DRAW THE MRNA        Color[] someColors = {Color.cyan, Color.yellow, Color.green, Color.orange, Color.pink};        Color[] rnaColor = new Color[rnaStart.length];        int NUM_OF_COLORS = 5;        int RNA_HEIGHT_SCALE = RNA_ROW_HEIGHT/5; //number of pixels per log increase. // 5 logs should be enough        for (int i=0;i<rnaStart.length;i++){            rnaColor[i] = someColors[i%NUM_OF_COLORS];        }                g = makeMRNAGraphic(g, rnaStart, rnaLength, rnaCopyNumber, X_EDGE_MARGIN ,y+PROMOTER_HEIGHT+(RNA_ROW_HEIGHT/2), rnaColor, RNA_HEIGHT_SCALE, BP_PER_PIXEL);        		        g = makeDNAGraphic(g, ca, enteredDNA, X_EDGE_MARGIN, y, BP_PER_PIXEL, POLYMERASE_HEIGHT, PROMOTER_HEIGHT,        TERMINATOR_HEIGHT, NORMAL_DNA_HEIGHT, NUM_BETWEEN_TRACERS, ENTERED_DNA_WIDTH, ENTERED_DNA_HEIGHT, dnaArray);                                //System.out.println("Completed Single Visualization.");        return testImage;    } /* This method will tkae in a graphics object and add complexes starting at a given x,y position  * This should be set to the beginning of the DNA sequence that will be drawn (or is already drawn)  * Constants such as the sizes of particular elements must be passed to the method.  */    /**	 * This method takes a Graphics2D object and adds a representation of the DNA with complexes and genetic elements annotated onto it.  	 * @param g The Graphics2D object that the representation will be added to.	 * @param complexArray The Graphics2D object that 	 * @param enteredDNA	 * @param startX	 * @param startY	 * @param BP_PER_PIXEL	 * @param POLYMERASE_HEIGHT	 * @param PROMOTER_HEIGHT	 * @param TERMINATOR_HEIGHT	 * @param NORMAL_DNA_HEIGHT	 * @param NUM_BETWEEN_TRACERS	 * @param ENTERED_DNA_WIDTH	 * @param ENTERED_DNA_HEIGHT	 * @param dnaArray	 */    public static Graphics2D makeDNAGraphic(Graphics2D g, String[] complexArray, int enteredDNA, int startX, int startY, int BP_PER_PIXEL,									 int POLYMERASE_HEIGHT, int PROMOTER_HEIGHT , int TERMINATOR_HEIGHT, int NORMAL_DNA_HEIGHT, int NUM_BETWEEN_TRACERS,									 int ENTERED_DNA_WIDTH, int ENTERED_DNA_HEIGHT, int[] dnaArray){                // these store the ID of the previous section, so will know when a new section is entered, thus time to draw a new feature.        int dnaPrevSection = -10;         String compPrevSection = "999-999-999";        				        //need to fix dnaX so that the margin is actually used somewhere, instead of just written over.        int X_EDGE_MARGIN = startX;        int dnaX = X_EDGE_MARGIN;        int compX = X_EDGE_MARGIN;        int dnaRectWidth=0;        int compRectWidth=0;        int genomeSize = dnaArray.length;		int y = startY; //the posistioning will be taken care of outside hte program.        int MAX_NUM_OF_POLY_PER_ORGANISM = 3;  // can read this by getting the greater number from tReadMol        Rectangle2D rectangle = new Rectangle2D.Double();        Ellipse2D circle = new Ellipse2D.Double();                //This section is for drawing the entered DNA bar.		        int entX = (enteredDNA/BP_PER_PIXEL);		int entY = (int) (y - (ENTERED_DNA_HEIGHT/2));        g.setPaint(Color.yellow);        rectangle.setFrame(entX,entY, ENTERED_DNA_WIDTH, ENTERED_DNA_HEIGHT);		g.fill(rectangle);		        boolean dnaSectionEnd = false;        boolean compSectionEnd = false;                // if (complexArray[timeInstance-1].length != dnaArray.length){} //throw an exception }        //      this will ensure that the DNA strand being written and the complexes being placed on it are the same size.                int dnaCount = 0;        int compCount = 0;        int compXCorrection = 0;        int dnaXCorrection = 0;                for (int i=0;i<genomeSize;i++){                                    //-----------------CHECK FOR NEW SECTIONS -- if new section is entered set dnaSectionEnd = true.                        //COMPLEXES            if(!(complexArray[i].equals(compPrevSection))){			                compSectionEnd=true;			}            else{                compCount++;                // if still in the same section increment the size of the Complex by one bp                compSectionEnd=false;            }                        // DNA            if((dnaArray[i]!=dnaPrevSection)){                dnaSectionEnd=true;                //System.out.println("new section: " + dnaArray[i] + " at bp " + i);            }            else{                dnaCount++;                // if still in the same section increment the size of the DNA segment by one bp                dnaSectionEnd=false;            }                        //if the end of the genome is reached, end the current DNA section and Complex section.            if (i==dnaArray.length-1){                dnaSectionEnd=true;                compSectionEnd = true;                //System.out.println("last section ends at bp: " + i);            }            // COMPLEXES SECTION END            if(compSectionEnd){                                // compRectWidth is the size of the element to draw on the screen. (compCount is size of the element in bp).                compRectWidth = compCount/BP_PER_PIXEL;				compRectWidth=1;				//}                compCount = 0;				compXCorrection = 0;				/* Find the location to start drawing the new component.  i is the current bp, divide by BP_PER_PIXEL to find the					* current pixel.  The compXCorrection must be added in order to account for athe fact that unfilled pixel = a whole pixel.					*/                compX = (i/BP_PER_PIXEL)-compRectWidth+compXCorrection;                                               // Draw T7 RNAP                StringTokenizer compSt = new StringTokenizer(compPrevSection,"-");                int organism = Integer.parseInt(compSt.nextToken());                int molecule = Integer.parseInt(compSt.nextToken());                int idNum = Integer.parseInt(compSt.nextToken());                                if (((organism) == 1)){ // T7 RNAP                    Color paintColor = Color.red;					                    int heightShift=(molecule%MAX_NUM_OF_POLY_PER_ORGANISM)*(POLYMERASE_HEIGHT/4); //					System.out.println("molecule="+molecule);                    for(int j=0;j<(molecule-5);j++){						paintColor.darker(); //ID=2 first T7RNAP//						System.out.println("j=" + j);					}					g.setPaint(paintColor);                    rectangle.setRect(compX,(y-POLYMERASE_HEIGHT), compRectWidth, POLYMERASE_HEIGHT);                    g.fill(rectangle);                }                                // Draw E.Coli RNAP                if (organism == 2){ // E.Coli RNAP                    Color paintColor = Color.yellow;                    //int heightShift=(molecule%MAX_NUM_OF_POLY_PER_ORGANISM)*(POLYMERASE_HEIGHT/4);                     for(int j=0;j<(molecule-2);j++){						paintColor.darker(); //ID=2 first ECRNAP					}					g.setPaint(paintColor);                    rectangle.setRect(compX,(y-POLYMERASE_HEIGHT), compRectWidth, POLYMERASE_HEIGHT);                    g.fill(rectangle);                }                                // Draw blank space in between                if (organism == 0){                    // currently this does nothing, just leaves background which is black.                }                                compPrevSection = complexArray[i];            }                        //DNA SECTION END            if(dnaSectionEnd){                dnaRectWidth = dnaCount/BP_PER_PIXEL;                                // this is analagous to above using complexes                if (dnaCount>=0){                    if (((dnaCount % BP_PER_PIXEL)!=0) && (dnaRectWidth!=0)){                        dnaRectWidth++;                        dnaCount = -1*((BP_PER_PIXEL)-(dnaCount % BP_PER_PIXEL));                        dnaXCorrection = 1;                    }                    else{                        dnaCount = 0;                        dnaXCorrection = 0;                    }                }                                dnaX = (i/BP_PER_PIXEL)-dnaRectWidth+dnaXCorrection;                if(dnaRectWidth<1){					dnaRectWidth=1;				}				                // --- START DRAW DNA COMPONENTS                                // Draw T7 promoter                if ((dnaPrevSection/1000) == 1){                    g.setPaint(Color.green);                    rectangle.setRect(dnaX,y,dnaRectWidth,PROMOTER_HEIGHT);                    g.fill(rectangle);                }                // Draw E. Coli promoter                if ((dnaPrevSection/1000) == 2){                    g.setPaint(Color.green);                    rectangle.setRect(dnaX,y,dnaRectWidth,PROMOTER_HEIGHT);                    g.fill(rectangle);                }                // Draw Terminator                if ((dnaPrevSection/1000) == 7){                    g.setPaint(Color.orange);                    rectangle.setRect(dnaX,y,dnaRectWidth,TERMINATOR_HEIGHT);                    g.fill(rectangle);                }                // Draw "normal" DNA                if (dnaPrevSection == 0){                    g.setPaint(Color.lightGray);                    rectangle.setRect(dnaX,y,dnaRectWidth,NORMAL_DNA_HEIGHT);                    g.fill(rectangle);                }                dnaPrevSection = dnaArray[i];                            }        }        return g;    }    }